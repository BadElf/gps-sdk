# BadElfSampleGnssApp (Swift)
=============================

This sample iOS app demonstrates how to configure detect, connect, and configure our modern and legacy GNSS receivers for NMEA streaming.

It was 90% generated by Gemini using the prompt below, which was refined over 10-15 iterations.  Some manual edits were then made to get the sample to compile in Xcode, and further changes were made after testing with real HW.

### Prompt for Gemini

Build a sample iOS app called BadElfGnssSampleApp written in Swift and SwiftUI that meets the following requirements:

1. Uses the EAAccessory framework to detect and automatically open communications with an external GNSS receiver  
2. The receiver supports the “com.bad-elf.gnss” and/or "com.bad-elf.gps" protocol strings.  If available on the EAAccessory, the first protocol should be used.  If not, the second protocol can be used and the app should set isLegacy flag.  
3. The app should open an EASession on the first GNSS receiver it finds, and stay connected to that receiver until it disconnects, at which point it can connect to the next receiver it finds.  
4. Once the EASession is open, the receiver will start streaming data in NMEA format.    
5. The data stream may also include unknown binary packets or corrupted NMEA messages, so the parser should be fault tolerant and validate the NMEA sentence checksums before parsing them.  
6. Incoming NMEA messages will start with the $ character, and end with a CR, LF, or CR/LF sequence.  
7. Incoming bytes should be stored in a buffer.  When processing the buffer for valid NMEA sentences, discard any leading bytes that aren’t the $ character.  Then find the next CR, LF, indicating the end of the sentence.  If another $ is found before a CR or LF, discard the bytes up to that point and try again.  
8. When parsing NMEA messages with comma separated values, it is valid for some fields to be empty, so you can’t simply split the string based on the comma character.  
9. When the EASession output stream is open for writing, the app should send a configuration message once and set a flag indicating isConfigured.    
10. If the accessory was not marked as isLegacy, the configuration message will be the string below, with a NMEA checksum and CR/LF appended after replacing the values for APP\_NAME, APP\_BUNDLE\_ID, and APP\_VERSION at runtime from NSBundle:

    $PBEJS,{"method":"session","params":{"appName":"APP\_NAME","appId":"APP\_BUNDLE\_ID","appVersion":"APP\_VERSION","msgs":"NMEA"}}"

11. If the accessory was marked as isLegacy, the app should send a binary configuration message via EASession to get NMEA messages flowing.  The binary packet is defined as the following bytes in hex format: (24 be 00 11 05 01 02 05 31 01 32 04 33 01 64 0d 0a)   
12. From the GGA sentence, the app should parse the following GPS parameters: timestamp, latitude, longitude, altitude, and fix type.  
13. From the RMC sentence, the app should parse the timestamp, speed, course, and date.  
14. From the GST sentence, the app should parse the latitude and longitude error estimates and compute the horizontal accuracy in meters using Patagream theorem.  Use fields 6 and 7 for the input values.  
15. If the GGA, RMC, and GST sentences do not have matching timestamps, the data from all three sentences should be discarded.  
16. The app UI should be modern and clean, with simple icons, displaying the following:   
    1. receiver model name, serial number, and connection status  
    2. Realtime GPS parameters: timestamp, horizontal accuracy, and fix type  
    3. A toggle button, enabled by default, that enables or disables the auto-connect behavior.  This button should be located at the bottom of the screen.   
17. If needed, make sure to import the Combine library and objects should conform to ObservableObject protocol if needed.  
18. Don’t use EAAccessoryManager.shared() for anything except EAAccessoryManager.shared().connectedAccessories and EAAccessoryManager.shared().registerForLocalNotifications().  Don’t make any references to the field areNotificationsEnabled.    
19. Instead of using a timer, perform the auto-connect logic when EAAccessory events are fired, the app launches, or the app comes to the foreground or becomes active.  
20. Instead of DGPS, use the term SBAS.  
21. Put all the swift code in a single file
